# 字母异位词分组
给你一个字符串数组，请你将 字母异位词 组合在一起。可以按任意顺序返回结果列表。

字母异位词 是由重新排列源单词的字母得到的一个新单词，所有源单词中的字母通常恰好只用一次。

 

示例 1:

输入: strs = ["eat", "tea", "tan", "ate", "nat", "bat"]
输出: [["bat"],["nat","tan"],["ate","eat","tea"]]
示例 2:

输入: strs = [""]
输出: [[""]]
示例 3:

输入: strs = ["a"]
输出: [["a"]]

按照题目要求将含有相同字母的异位词作为一组返回。则需要一个标志来判断是否是异位词。

排序：
       同一组异位词，在排序后，得到的结果应该是相同的。可定义Hashmap,将排序结果作为键，用vector向量作为值，存放具有相同
键的string。

遍历后，再用一个vector来存放每一个键的值。
       在官方解答中，有一个emplace_back()函数。在C++11中新加了这个函数。在C++中我们会对stl的各种容器进行操作，比如vecto
r，map，set等。

在引入右值引用前，转移构造函数，转移复制运算符之前，通常使用push_back()向容器中加入一个右值元素(临时对
象)时，首先会调用构造函数构造这个临时对象，然后需要调用拷贝构造函数将这个临时对象放入容器中。原来的临时变量释放。这样
造成的问题就是临时变量申请资源的浪费。

 引入了右值引用，转移构造函数后，push_back()右值时就会调用构造函数和转移构造函
数,如果可以在插入的时候直接构造，就只需要构造一次即可，这就是emplace_back()函数。即push_back()函数需先构造一个临时的元
素，再调用复制构造函数，将值传入，再将这个构造的元素释放掉。而在emplace_back()函数中，可以直接构造元素，将值给予这个元
素，省去了临时构造这个过程。

计数：
     同一组异位词，每个字母的出现次数应该是相同的，则在hashmap中，用大小26的数组记录每个字母的出现次数作为键，用vector存
放异位的字符串作为值，遍历结束后，将每一个键的值用一个容器存放返回。

    decltype关键字：是一种类型标说明符，它的作用是选择并返回操作数的数据类型，它的出现主要是解决复杂的类型声明。
   // sum的类型就是函数f返回的类型
     decltype(f()) sum = x;

随着程序越来越复杂，程序中用到的类型也越来越多，这种复杂性体现在两个方面。

一是一些类型难于“拼写”，它们的名字既难记又容易写错，还无法明确体现其真实目的和含义。

二是有时候根本搞不清到底需要的类型是什么，程序员不得不回过头去从程序的上下文寻求帮助。

解决问题一，可以使用类型别名技术。

解决问题二，可以使用auto和本文的主题：decltype。
